OPTION ARB_precision_hint_fastest;

TEMP	light, color, R1, R2, localNormal, specular;

PARAM	subOne = { -1, -1, -1, -1 };
PARAM	scaleTwo = { 2, 2, 2, 2 };
PARAM	grayscale = { 0.3, 0.59, 0.11, 0.0};

# load the specular half angle first, because
# the ATI shader gives a "too many indirections" error
# if this is done right before the texture indirection

#-----------------
$if !r_shaderPreferALU
TEX	specular, fragment.texcoord[6], $normalCubeMap, CUBE;
MAD	specular, specular, scaleTwo, subOne;

$else

# instead of using the normalization cube map, normalize with math
DP3		specular.x, fragment.texcoord[6], fragment.texcoord[6];
RSQ		specular.x, specular.x;
MUL		specular, specular.x, fragment.texcoord[6];
$endif
#-----------------

$ifdef enable_instdither
MUL R1.xy, fragment.position, 0.0625;
TEX R1, R1, $noiseMap, 2D;
SLT R1.w, fragment.texcoord[6].w, R1.w;
KIL	-R1.w;
$endif


#
# the amount of light contacting the fragment is the
# product of the two light projections and the surface
# bump mapping
#

# perform the diffuse bump mapping

#-----------------
$if !r_shaderPreferALU
TEX	light, fragment.texcoord[0], $normalCubeMap, CUBE;
MAD	light, light, scaleTwo, subOne;
$else
# instead of using the normalization cube map, normalize with math
DP3		light.x, fragment.texcoord[0], fragment.texcoord[0];
RSQ		light, light.x;
MUL		light, light.x, fragment.texcoord[0];
$endif
#-----------------

#TEX	localNormal, fragment.texcoord[1], $bumpMap, 2D;
$if !r_dxnNormalMaps
#MOV localNormal.x, localNormal.a;
$endif
#MAD	localNormal, localNormal, scaleTwo, subOne;

$if r_normalizeNormalMaps
#MOV		localNormal.z, 0;
#DP3		R1.x, localNormal,localNormal;
#ADD		R1.x, 1, -R1.x;
#RSQ		R1.x, R1.x;
#RCP		localNormal.z, R1.x;
$endif

#DP3	light, light, localNormal;
MOV	light, 1;

# modulate by the light projection
TXP	R1, fragment.texcoord[3], $lightProjectionMap, 2D;
MUL	light, light, R1;

# modulate by the light falloff
TEX	R1, fragment.texcoord[2], $lightFalloffMap, 2D;
MUL	light, light, R1;

#
# the light will be modulated by the diffuse and
# specular surface characteristics
#

# modulate by the diffuse map and constant diffuse factor
TEMP diffuse;
TEX	diffuse, fragment.texcoord[4], $diffuseMap, 2D;
MUL	color, diffuse, $diffuseColor;
$ifdef alphatest_kill
TEMP	_AR0;
SUB		_AR0.a, color.a, $alphaThresh;
KIL		_AR0.a;
$endif
$ifdef alphatocoverage
TEMP	_AR0;
SUB		_AR0.a, color.a, 0.1;
KIL		_AR0.a;
$endif

# perform the specular bump mapping
#DP3	specular, specular, localNormal;
MOV specular, specular.z;

$if !r_shaderPreferALU
	# perform a dependent table read for the specular falloff
	TEX	R1, specular, $specularTable, 2D;
$else
	# Specular falloff: (sat(4x-3))^2 matches the function inside the specular table texture
	MAD_SAT R1.x, specular.x, 4.0, -3.0;
	MUL R1.x, R1.x, R1.x;
$endif

# modulate by the constant specular factor
MUL	R1, R1.x, $specularColor;

# modulate by the specular map * 2
TEX	R2, fragment.texcoord[5], $specularMap, 2D;
ADD	R2, R2, R2;
MAD	color, R1, R2, color;


MUL	color, light, color;

# modify by the vertex color

MUL color, color, fragment.color;

$if ( r_megaDrawMethod != 0 )
$ifdef amblit
LRP result.color.rgb, fragment.color.secondary.x, $fogColor, color;
$else
SUB R1.x, 1, fragment.color.secondary.x;
MUL result.color.rgb, color, R1.x;
$endif
$else
MOV result.color.rgb, color;
$endif


#MUL R1, R1, R2;
#MUL R1, R1, light;
#DP3 R1, R1, grayscale;
$ifdef alphatocoverage
MUL result.color.a, diffuse.a, 1.5;
$else
MOV result.color.a,  1;#diffuse;#R1;
$endif
# this should be better on future hardware, but current drivers make it slower
#MUL result.color.xyz, color, fragment.color;

