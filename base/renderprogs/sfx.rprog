/***************************************************************************

	Misc special effect materials

***************************************************************************/

renderBinding rainbowMap { texture { textures/effects/stroggshell2.tga } }

renderProgram sfx/desecratorEffect {
	state {
		depthFunc equal
		blend GL_ONE, GL_ONE
	}

	program vertex cg { <%
	
		struct VsInputs {
			float3 pos : $positionAttrib;
			float2 tex : $texCoordAttrib;
			float3 normal : $normalAttrib;
			float4 tangent : $tangentAttrib;			
			$if r_32ByteVtx
			float4 signs : $signAttrib;
			$endif			
		};
	
		struct VsOutputs {
			float2 tex	: TEXCOORD0;
			float3 toEye	: TEXCOORD1;
			float3 pos	: TEXCOORD2;
			float3 toLight	: TEXCOORD3;
		};
		
		uniform float3 viewOrigin : $viewOrigin;
		uniform float3 sunDirection : $sunDirection;
		
		float GetZ( float2 value, float sign ) {
			return ( sqrt( 1.0f - ( dot( value.xy, value.xy ) ) ) * ( sign - 1.f ) );
		}

		
		VsOutputs vertex( VsInputs indata ) {
			VsOutputs outData;

			$if r_32ByteVtx
			indata.tex *= 1.f/4096.f;
			indata.normal.xy *= 1.f / 32767.f;
			indata.tangent.xy *= 1.f / 32767.f;
			indata.normal.z = GetZ( indata.normal.xy, indata.signs.x );
			indata.tangent.z = GetZ( indata.tangent.xy, indata.signs.y );
			indata.tangent.w = ( indata.signs.z - 1.f );
			$endif

			float3 tangent = indata.tangent.xyz;
			float3 biTangent = cross( indata.normal, tangent ) * indata.tangent.w;

			float3 toEye = indata.pos - viewOrigin;
			outData.toEye.x = dot( tangent, toEye );
			outData.toEye.y = dot( biTangent, toEye );
			outData.toEye.z = dot( indata.normal, toEye );
			outData.toEye = normalize( outData.toEye );

			outData.toLight.x = dot( tangent, sunDirection );
			outData.toLight.y = dot( biTangent, sunDirection );
			outData.toLight.z = dot( indata.normal, sunDirection );

			outData.pos = indata.pos;
			outData.tex = indata.tex;

			return outData;
		}		
	%> }

	program fragment cg { <%
		struct VsOutputs {
			float2 tex	: TEXCOORD0;
			float3 toEye	: TEXCOORD1;
			float3 pos	: TEXCOORD2;
			float3 toLight	: TEXCOORD3;
		};
		
		sampler2D rainbowMap : $map;
		sampler2D bumpMap : $bumpMap;
		sampler2D specularMap : $specularMap;
		samplerCUBE skyMap : $skyGradientCubeMap;
		
		float4 fragment( VsOutputs indata ) : COLOR {
			float4 normal = tex2D( bumpMap, indata.tex );
			float4 gloss = tex2D( specularMap, indata.tex ) * 1.8 + 0.05;
			float4 skyColor = texCUBE( skyMap , float3( 1.0, 1.0, 1.0 ) );

			$if !r_dxnNormalMaps
			normal.x = normal.a;
			$endif
			
			normal = normal * 2 - 1;
			normal.z = sqrt( 1.f - dot( normal.xy, normal.xy ) );

			float dotp = dot( normal.rgb, -indata.toEye );
			float lookup = dotp;

			return tex2D( rainbowMap, float2( lookup, 0) ) * gloss * skyColor * 1.5;
		}
	%> }
}

/*
* Desaturate and tint with the stage color
*	parameters array is: Amount to desaturate
*/
renderProgram sfx/desaturate {

	program vertex arb { <%
		OPTION ARB_position_invariant;
		MOV	result.texcoord[0], $texCoordAttrib;
	%> }
	
	program fragment arb { <%
		OPTION ARB_precision_hint_fastest;
		PARAM	scale = {0.20, 0.11, 0.69, 1.0};
		TEMP	colorSource, R0;

		TEX		colorSource, fragment.texcoord[0], $map, 2D;
		MOV		R0.a, colorSource.a;

		# greyscale factor
		DP3		R0.rgb, colorSource, scale;
		LRP		R0.rgb, $parameters.x, colorSource, R0;

		MUL		result.color, $diffuseColor, R0;
	%> }
	
}

/*
* Desaturate and do some extra color processing on the map
*	parameters array is: Result Alpha, Exposure (just a color scale, can be > 1)
*/
renderProgram sfx/warroom_desat {

	program vertex arb { <%
		OPTION ARB_position_invariant ;
		MOV	result.texcoord[0], $texCoordAttrib;
	%> }
	
	program fragment arb { <%
		OPTION ARB_precision_hint_fastest;
		PARAM	scale = {0.20, 0.11, 0.69, 1.0};
		TEMP colorSource, R0;

		TEX	colorSource, fragment.texcoord[ 0 ], $map, 2D;

		# greyscale factor
		DP3	R0, colorSource, scale;
		LRP	colorSource, 0.5, colorSource, R0;

		# exposure
		MUL_SAT		R0, $parameters.y, colorSource;

		# colorize
		MUL		result.color.rgb, R0, $diffuseColor;

		MOV result.color.a, $parameters.x;
	%> }
}

/*
* A static surface with cubemap reflections
*	parameters array is: Exponent power, brightness scale, base reflection
*	+ the enviroment is squared, giving a more plasticy look than the window glass one
*	+ there is no support for a mask all of the material is equally reflective
*/
renderProgram sfx/visor {

	hwSkinningVersion sfx/visor_skinned sfx/visor_hardskinned

	program vertex arb { <%
		OPTION ARB_position_invariant;
		TEMP R1, bitangent;

		XPD		bitangent,  $normalAttrib, $tangentAttrib;
		MUL		bitangent, bitangent, $tangentAttrib.w;

		# texture coords
		DP4		result.texcoord[0].x, $texCoordAttrib, $diffuseMatrix_s;
		DP4		result.texcoord[0].y, $texCoordAttrib, $diffuseMatrix_t;
		
		# vector to eye
		SUB		R1, $positionAttrib, $viewOrigin;
		DP3		result.texcoord[2].x, R1, $transposedModelMatrix_x;
		DP3		result.texcoord[2].y, R1, $transposedModelMatrix_y;
		DP3		result.texcoord[2].z, R1, $transposedModelMatrix_z;

		# tangent->world matrix
		DP3		result.texcoord[3].x, $tangentAttrib, $transposedModelMatrix_x;
		DP3		result.texcoord[3].y, bitangent, $transposedModelMatrix_x;
		DP3		result.texcoord[3].z, $normalAttrib, $transposedModelMatrix_x;

		DP3		result.texcoord[4].x, $tangentAttrib, $transposedModelMatrix_y;
		DP3		result.texcoord[4].y, bitangent, $transposedModelMatrix_y;
		DP3		result.texcoord[4].z, $normalAttrib, $transposedModelMatrix_y;

		DP3		result.texcoord[5].x, $tangentAttrib, $transposedModelMatrix_z;
		DP3		result.texcoord[5].y, bitangent, $transposedModelMatrix_z;
		DP3		result.texcoord[5].z, $normalAttrib, $transposedModelMatrix_z;	
	%> }
	
	program fragment arb { <%
		OPTION ARB_precision_hint_fastest;
		TEMP R1, R2, R3, R4, eye, mix;

		# get normal from normal map
		TEX		R1, fragment.texcoord[0], $bumpMap, 2D;
		$if !r_dxnNormalMaps
		MOV		R1.x, R1.a;
		$endif
		MAD		R2, R1, 2, -1;
		
		$if r_normalizeNormalMaps		
		MOV		R2.z, 0;
		DP3		R1.x, R2,R2;
		ADD		R1.x, 1, -R1.x;
		RSQ		R1.x, R1.x;
		RCP		R2.z, R1.x;
		$endif
		

		# put in world space
		DP3		R1.x, R2, fragment.texcoord[3];
		DP3		R1.y, R2, fragment.texcoord[4];
		DP3		R1.z, R2, fragment.texcoord[5];

		# normalize to eye
		DP3		eye.w, fragment.texcoord[2], fragment.texcoord[2];
		RSQ		eye.w, eye.w;
		MUL		eye, fragment.texcoord[2], eye.w;

		# calc reflection vector: i - 2 * dot(i, n) * n
		DP3		R2, eye, R1;
		MUL		R2, R2, 2;
		MAD		R4, -R1, R2.x, eye;

		# reflect refract mixing (sorta fresnel)
		DP3_SAT		R1, -eye, R1;
		SUB		R1, 1, R1;
		POW		mix, R1.x, $parameters.x;

		# lookup textures and interpolate
		TEX		R4, R4, $environmentCubeMap, CUBE;
		MUL		R4, R4, R4;
		MUL		result.color, R4, $parameters.y;
		#MOV		result.color, R4;
		ADD		mix.a, mix, $parameters.z;
		MUL		result.color.a, $diffuseColor.a, mix.a;
		#MOV		result.color.a, 1;
	%> }
}

renderProgram sfx/visor_skinned {

	program vertex arb { <%
		TEMP R1, bitangent;

		TEMP	R0;

		TEMP	position;
		TEMP	normal;
		TEMP	tangent;
		useTemplate skinningMatrix_ARB< "position", "normal", "tangent", "bitangent" >		

		XPD		bitangent,  $normalAttrib, $tangentAttrib;
		MUL		bitangent, bitangent, $tangentAttrib.w;

		# texture coords
		DP4		result.texcoord[0].x, $texCoordAttrib, $diffuseMatrix_s;
		DP4		result.texcoord[0].y, $texCoordAttrib, $diffuseMatrix_t;
		
		# vector to eye
		SUB		R1, position, $viewOrigin;
		DP3		result.texcoord[2].x, R1, $transposedModelMatrix_x;
		DP3		result.texcoord[2].y, R1, $transposedModelMatrix_y;
		DP3		result.texcoord[2].z, R1, $transposedModelMatrix_z;

		# tangent->world matrix
		DP3		result.texcoord[3].x, tangent, $transposedModelMatrix_x;
		DP3		result.texcoord[3].y, bitangent, $transposedModelMatrix_x;
		DP3		result.texcoord[3].z, normal, $transposedModelMatrix_x;

		DP3		result.texcoord[4].x, tangent, $transposedModelMatrix_y;
		DP3		result.texcoord[4].y, bitangent, $transposedModelMatrix_y;
		DP3		result.texcoord[4].z, normal, $transposedModelMatrix_y;

		DP3		result.texcoord[5].x, tangent, $transposedModelMatrix_z;
		DP3		result.texcoord[5].y, bitangent, $transposedModelMatrix_z;
		DP3		result.texcoord[5].z, normal, $transposedModelMatrix_z;	
	%> }
	
	program fragment reference sfx/visor
}

renderProgram sfx/visor_hardskinned {

	program vertex arb { <%
		TEMP R1, bitangent;

		TEMP	position;
		TEMP	normal;
		TEMP	tangent;
		TEMP	R0;

		useTemplate hardSkinningMatrix_ARB< "position", "normal", "tangent", "bitangent" >		

		# texture coords
		DP4		result.texcoord[0].x, $texCoordAttrib, $diffuseMatrix_s;
		DP4		result.texcoord[0].y, $texCoordAttrib, $diffuseMatrix_t;
		
		# vector to eye
		SUB		R1, position, $viewOrigin;
		DP3		result.texcoord[2].x, R1, $transposedModelMatrix_x;
		DP3		result.texcoord[2].y, R1, $transposedModelMatrix_y;
		DP3		result.texcoord[2].z, R1, $transposedModelMatrix_z;

		# tangent->world matrix
		DP3		result.texcoord[3].x, tangent, $transposedModelMatrix_x;
		DP3		result.texcoord[3].y, bitangent, $transposedModelMatrix_x;
		DP3		result.texcoord[3].z, normal, $transposedModelMatrix_x;

		DP3		result.texcoord[4].x, tangent, $transposedModelMatrix_y;
		DP3		result.texcoord[4].y, bitangent, $transposedModelMatrix_y;
		DP3		result.texcoord[4].z, normal, $transposedModelMatrix_y;

		DP3		result.texcoord[5].x, tangent, $transposedModelMatrix_z;
		DP3		result.texcoord[5].y, bitangent, $transposedModelMatrix_z;
		DP3		result.texcoord[5].z, normal, $transposedModelMatrix_z;	
	%> }
	
	program fragment reference sfx/visor
}

/*
* A static surface with cubemap reflections
*	parameters array is: Exponent power, brightness scale, base reflection
*
*	The "diffusemap" alpha is used as a mask that indicates where the glassy bits
*	are in the material. The colors of the diffuse are NOT used
*/
renderProgram sfx/windowglass {

	instanceVersion sfx/windowglass_instance

	program vertex arb { <%
		OPTION ARB_position_invariant;
		TEMP R1, bitangent;

		XPD		bitangent,  $normalAttrib, $tangentAttrib;
		MUL		bitangent, bitangent, $tangentAttrib.w;

		# texture coords
		MOV		result.texcoord[0], $texCoordAttrib;
		DP4		result.texcoord[0].x, $texCoordAttrib, $diffuseMatrix_s;
		DP4		result.texcoord[0].y, $texCoordAttrib, $diffuseMatrix_t;
		

		# vector to eye in worldspace
		SUB		R1, $positionAttrib, $viewOrigin;
		DP3		result.texcoord[2].x, R1, $transposedModelMatrix_x;
		DP3		result.texcoord[2].y, R1, $transposedModelMatrix_y;
		DP3		result.texcoord[2].z, R1, $transposedModelMatrix_z;

		# tangent->world matrix
		DP3		result.texcoord[3].x, $tangentAttrib, $transposedModelMatrix_x;
		DP3		result.texcoord[3].y, bitangent, $transposedModelMatrix_x;
		DP3		result.texcoord[3].z, $normalAttrib, $transposedModelMatrix_x;

		DP3		result.texcoord[4].x, $tangentAttrib, $transposedModelMatrix_y;
		DP3		result.texcoord[4].y, bitangent, $transposedModelMatrix_y;
		DP3		result.texcoord[4].z, $normalAttrib, $transposedModelMatrix_y;

		DP3		result.texcoord[5].x, $tangentAttrib, $transposedModelMatrix_z;
		DP3		result.texcoord[5].y, bitangent, $transposedModelMatrix_z;
		DP3		result.texcoord[5].z, $normalAttrib, $transposedModelMatrix_z;	
		
		TEMP R0;
		MAD	R0, $colorAttrib, $colorModulate, $colorAdd;
		MUL result.color, $diffuseColor, R0;
		
	%> }
	
	program fragment arb { <%
		OPTION ARB_precision_hint_fastest;
		TEMP R1, R2, R3, R4, eye, mix;

		# get normal from normal map
		TEX		R1, fragment.texcoord[0], $bumpMap, 2D;
		$if !r_dxnNormalMaps
		MOV		R1.x, R1.a;
		$endif
		MAD		R2, R1, 2, -1;
		
		$if r_normalizeNormalMaps
		MOV		R2.z, 0;
		DP3		R1.x, R2,R2;
		ADD		R1.x, 1, -R1.x;
		RSQ		R1.x, R1.x;
		RCP		R2.z, R1.x;
		$endif
		

		# put in world space
		DP3		R1.x, R2, fragment.texcoord[3];
		DP3		R1.y, R2, fragment.texcoord[4];
		DP3		R1.z, R2, fragment.texcoord[5];

		# normalize to eye
		DP3		eye.w, fragment.texcoord[2], fragment.texcoord[2];
		RSQ		eye.w, eye.w;
		MUL		eye, fragment.texcoord[2], eye.w;

		# calc reflection vector: i - 2 * dot(i, n) * n
		DP3		R2, eye, R1;
		MUL		R2, R2, 2;
		MAD		R4, -R1, R2.x, eye;

		# reflect refract mixing (sorta fresnel)
		DP3_SAT	R1, -eye, R1;
		SUB		R1, 1, R1;
		POW		mix, R1.x, $parameters.x;

		# lookup textures and interpolate
		TEX		R4, R4, $environmentCubeMap, CUBE;
		TEX		R2, fragment.texcoord[0], $diffuseMap, 2D;
		
		TEMP	col;
		MUL		col.rgb, R4, $parameters.y;
		ADD		mix, mix, $parameters.z;
		MUL		col.a, R2.a, mix;
		
		MUL		result.color, col, fragment.color;
	%> }
}

renderProgram sfx/windowglass_instance {

	program vertex arb { <%
		TEMP R1, bitangent;

		TEMP _pos;
		TEMP _nrm;
		TEMP _tan;
		DP4 _pos.x, vertex.texcoord[5], $positionAttrib;
		DP4 _pos.y, vertex.texcoord[6], $positionAttrib;
		DP4 _pos.z, vertex.texcoord[7], $positionAttrib;
		MOV _pos.w, $positionAttrib.w;

		DP3 _nrm.x, vertex.texcoord[5], $normalAttrib;
		DP3 _nrm.y, vertex.texcoord[6], $normalAttrib;
		DP3 _nrm.z, vertex.texcoord[7], $normalAttrib;

		DP3 _tan.x, vertex.texcoord[5], $tangentAttrib;
		DP3 _tan.y, vertex.texcoord[6], $tangentAttrib;
		DP3 _tan.z, vertex.texcoord[7], $tangentAttrib;

		PARAM  mvp[4]       = { state.matrix.mvp };
		OUTPUT oPos         = result.position;
		# Transform the vertex to clip coordinates. 
		DP4   oPos.x, mvp[0], _pos;
		DP4   oPos.y, mvp[1], _pos;
		DP4   oPos.z, mvp[2], _pos;
		DP4   oPos.w, mvp[3], _pos;


		XPD		bitangent,  _nrm, _tan;
		MUL		bitangent, bitangent, $tangentAttrib.w;

		# texture coords
		MOV		result.texcoord[0], $texCoordAttrib;
		DP4		result.texcoord[0].x, $texCoordAttrib, $diffuseMatrix_s;
		DP4		result.texcoord[0].y, $texCoordAttrib, $diffuseMatrix_t;
		

		# vector to eye in worldspace
		SUB		R1, _pos, $viewOrigin;
		DP3		result.texcoord[2].x, R1, $transposedModelMatrix_x;
		DP3		result.texcoord[2].y, R1, $transposedModelMatrix_y;
		DP3		result.texcoord[2].z, R1, $transposedModelMatrix_z;

		# tangent->world matrix
		DP3		result.texcoord[3].x, _tan, $transposedModelMatrix_x;
		DP3		result.texcoord[3].y, bitangent, $transposedModelMatrix_x;
		DP3		result.texcoord[3].z, _nrm, $transposedModelMatrix_x;

		DP3		result.texcoord[4].x, _tan, $transposedModelMatrix_y;
		DP3		result.texcoord[4].y, bitangent, $transposedModelMatrix_y;
		DP3		result.texcoord[4].z, _nrm, $transposedModelMatrix_y;

		DP3		result.texcoord[5].x, _tan, $transposedModelMatrix_z;
		DP3		result.texcoord[5].y, bitangent, $transposedModelMatrix_z;
		DP3		result.texcoord[5].z, _nrm, $transposedModelMatrix_z;	
		
		TEMP R0;
		MAD	R0, $colorAttrib, $colorModulate, $colorAdd;
		MUL result.color, $diffuseColor, R0;
		
	%> }
	
	program fragment reference sfx/windowglass
}

/*
* A static surface with cubemap reflections
*	parameters array is: Exponent power, brightness scale, base reflection
*
*	The "mask" red is used as a mask that indicates where the glassy bits
*	are in the material.
*/
renderProgram sfx/windowglass_mask {

	instanceVersion sfx/windowglass_mask_instance 

	program vertex reference sfx/windowglass
	
	state {
		depthFunc less
	}
	
	program fragment arb { <%
		OPTION ARB_precision_hint_fastest;
		TEMP R1, R2, R3, R4, eye, mix;

		# get normal from normal map
		TEX		R1, fragment.texcoord[0], $bumpMap, 2D;
		$if !r_dxnNormalMaps
		MOV		R1.x, R1.a;
		$endif
		MAD		R2, R1, 2, -1;

		$if r_normalizeNormalMaps
		MOV		R2.z, 0;
		DP3		R1.x, R2,R2;
		ADD		R1.x, 1, -R1.x;
		RSQ		R1.x, R1.x;
		RCP		R2.z, R1.x;
		$endif

		# put in world space
		DP3		R1.x, R2, fragment.texcoord[3];
		DP3		R1.y, R2, fragment.texcoord[4];
		DP3		R1.z, R2, fragment.texcoord[5];

		# normalize to eye
		DP3		eye.w, fragment.texcoord[2], fragment.texcoord[2];
		RSQ		eye.w, eye.w;
		MUL		eye, fragment.texcoord[2], eye.w;

		# calc reflection vector: i - 2 * dot(i, n) * n
		DP3		R2, eye, R1;
		MUL		R2, R2, 2;
		MAD		R4, -R1, R2.x, eye;

		# reflect refract mixing (sorta fresnel)
		DP3_SAT	R1, -eye, R1;
		SUB		R1, 1, R1;
		POW		mix, R1.x, $parameters.x;

		# lookup textures and interpolate
		TEX		R4, R4, $environmentCubeMap, CUBE;
		TEX		R2, fragment.texcoord[0], $mask, 2D;
		
		MUL		result.color.rgb, R4, $parameters.y;
		ADD		mix, mix, $parameters.z;
		MUL		result.color.a, R2.x, mix;
		
		##MOV	result.color, R2.x;
		##MOV	result.color.a, 1;
	%> }
}

renderProgram sfx/windowglass_mask_instance {

	state {
		depthFunc less
	}
	
	program vertex reference sfx/windowglass_instance
	
	program fragment reference sfx/windowglass_mask
}

/*
* This is a replacement for the old "cubeMap" and "texgen reflect" materials
*  per-pixel cubic reflextion map calculation
*/
renderProgram sfx/cubemap {
	hwSkinningVersion sfx/cubeMapSkinningMatrix sfx/cubeMapHardSkinningMatrix

	program vertex arb { <%
		OPTION ARB_position_invariant;
		TEMP	R0;

		MOV	result.texcoord[0], $normalAttrib;
		SUB	result.texcoord[1], $viewOrigin, $positionAttrib;
		
		#support vertex colors and shader red,green,blue keywords
		MAD	R0, $colorAttrib, $colorModulate, $colorAdd;
		MUL	result.color, R0, $diffuseColor;
	%> }
	
	program fragment arb { <%
		OPTION ARB_precision_hint_fastest;
		TEMP	toEye, normal, R0;
		PARAM	scaleTwo = { 2, 2, 2, 2 };

		# normalize surface normal
		DP3	R0, fragment.texcoord[0], fragment.texcoord[0];
		RSQ	R0, R0.x;
		MUL	normal, fragment.texcoord[0], R0;

		# normalize vector to eye
		DP3	R0, fragment.texcoord[1], fragment.texcoord[1];
		RSQ	R0, R0.x;
		MUL	toEye, fragment.texcoord[1], R0;

		# calculate reflection vector
		DP3	R0, toEye, normal;
		MUL	R0, R0, normal;
		MAD	R0, R0, scaleTwo, -toEye;

		TEX	R0, R0, $environmentCubeMap, CUBE;
		MUL	result.color, R0, fragment.color;
	%> }
}

renderProgram sfx/cubeMapSkinningMatrix {
	program vertex arb { <%
		TEMP	position, normal;
		TEMP	R0;
		
		useTemplate skinningMatrix_ARB< "position", "normal" >

		MOV	result.texcoord[0], normal;
		SUB	result.texcoord[1], $viewOrigin, position;
		
		#support vertex colors and shader red,green,blue keywords
		MAD	R0, $colorAttrib, $colorModulate, $colorAdd;
		MUL	result.color, R0, $diffuseColor;
	%> }
	
	program fragment reference sfx/cubemap
}

renderProgram sfx/cubeMapHardSkinningMatrix {
	program vertex arb { <%
		TEMP	position, normal;
		TEMP	R0;
		
		useTemplate hardSkinningMatrix_ARB< "position", "normal" >

		MOV	result.texcoord[0], normal;
		SUB	result.texcoord[1], $viewOrigin, position;
		
		#support vertex colors and shader red,green,blue keywords
		MAD	R0, $colorAttrib, $colorModulate, $colorAdd;
		MUL	result.color, R0, $diffuseColor;
	%> }
	
	program fragment reference sfx/cubemap
}

/*
* Normal mapped smoke
*/
renderProgram sfx/litsmoke {

	program vertex cg { <%
		$include "litsmoke.hg"	
	%> }

	program fragment cg { <%
		$include "litsmoke.hg"	
	%> }
}

/*
* Normal mapped smoke with one dynamic light source
*/
renderProgram sfx/litsmoke_1 {

	program vertex cg { <%
		#define LIGHT_1
		$include "litsmoke.hg"		
	%> }

	program fragment cg { <%
		#define LIGHT_1
		$include "litsmoke.hg"	
	%> }
}


/*
* Normal mapped smoke trail
*	parameters array is: Scroll Factor
*/
renderProgram sfx/littrail {

	program vertex cg { <%
		#define TRAIL
		$include "litsmoke.hg"	
	%> }

	program fragment cg { <%
		#define TRAIL
		$include "litsmoke.hg"
	%> }
}

/*
* Deploy wireframe effect
*/
renderProgram sfx/deploy {

	program vertex cg { <%
	
		struct VsInputs {
			float3 pos	: $positionAttrib;
			float2 tex	: $texCoordAttrib;
			float4 tang 	: $tangentAttrib;
			float3 norm	: $normalAttrib;
			float4 color	: $colorAttrib;
		};

		struct VsOutputs {
			float3 pos	: TEXCOORD2;
		};

		VsOutputs vertex(VsInputs indata) {
			VsOutputs outData;
			outData.pos = indata.pos;
			return outData;
		}
	%> }

	program fragment cg { <%

		struct VsOutputs {
			float3 pos		: TEXCOORD2;
		};

		uniform float4 color : $diffuseColor;	//Fragment
		sampler2D texture : $map;

		float pattern( float3 pos, float freq) {
		   pos = pos*freq;
		   float a = tex2D( texture , pos.xy ).r;
		   a *= tex2D( texture , float2( 0.5, pos.z ) ).r;
		   a = 1-a;
		   return 0.1 + a;

		}

		float4 fragment(VsOutputs  indata) : COLOR {
			return color * pattern( indata.pos + 1.46, 0.058 );
		}
	%> }
}

renderProgram sfx/horizon {

	program vertex cg { <%
		struct VsInputs {
			float3 pos	: $positionAttrib;
			float2 tex	: $texCoordAttrib;
			float4 tang	: $tangentAttrib;
			float3 norm	: $normalAttrib;
			float4 color: COLOR0;
			$if r_32ByteVtx
			float4 signs : $signAttrib;
			$endif
		};

		struct VsOutputs {
			float2 tex	: TEXCOORD0;
			float3 toLight	: TEXCOORD1;
			float3 tang	: TEXCOORD2;
			float3 bino	: TEXCOORD3;
			float3 norm	: TEXCOORD4;
			float4 color	: COLOR0;
		};

		uniform float3 toSun 	: $sunDirection;
		
		float GetZ( float2 value, float sign ) {
			return ( sqrt( 1.0f - ( dot( value.xy, value.xy ) ) ) * ( sign - 1.f ) );
		}

		VsOutputs vertex(VsInputs indata) {
			VsOutputs outData;
			
			$if r_32ByteVtx
			indata.tex *= 1.f/4096.f;
			indata.norm.xy *= 1.f / 32767.f;
			indata.tang.xy *= 1.f / 32767.f;
			indata.norm.z = GetZ( indata.norm.xy, indata.signs.x );
			indata.tang.z = GetZ( indata.tang.xy, indata.signs.y );
			indata.tang.w = ( indata.signs.z - 1.f );
			$endif

			outData.tex = indata.tex;

			float3 tangent = indata.tang.xyz;
			float3 biTangent = cross( indata.norm, tangent ) * indata.tang.w;

			outData.toLight.x = dot( tangent, toSun );
			outData.toLight.y = dot( biTangent, toSun );
			outData.toLight.z = dot( indata.norm, toSun );



			//Transpose for ambient cubemap lookup
			outData.tang.x = tangent.x;
			outData.tang.y = biTangent.x;
			outData.tang.z = indata.norm.x;

			outData.bino.x = tangent.y;
			outData.bino.y = biTangent.y;
			outData.bino.z = indata.norm.y;

			outData.norm.x = tangent.z;
			outData.norm.y = biTangent.z;
			outData.norm.z = indata.norm.z;

			return outData;
		}
	%> }

	program fragment cg { <%
		struct VsOutputs {
			float2 tex	: TEXCOORD0;
			float3 toLight	: TEXCOORD1;
			float3 tang	: TEXCOORD2;
			float3 bino	: TEXCOORD3;
			float3 norm	: TEXCOORD4;
			float4 color	: COLOR0;
		};

		sampler2D diffuseMap : $diffuseMap;
		sampler2D normalMap : $bumpMap;
		samplerCUBE ambientCubemap : $ambientCubeMap;
		uniform float ambientBrightness : $ambientBrightness;

		uniform float4 sunColor	: $sunColor;

		float4 fragment(VsOutputs  indata) : COLOR {

			// Load diffuse
			float4 diffuse = tex2D( diffuseMap, indata.tex );
			if( diffuse.a < 0.5f ) discard;

			// Decode normal
			float4 normal = tex2D( normalMap, indata.tex ) * 2.0f - 1.0f;
			normal.x = normal.w;
			normal.z = sqrt( 1.f - dot( normal.xy, normal.xy ) );

			// Sunlight
			float3 sunLight = max( dot( normal.xyz, indata.toLight ), 0) * sunColor.rgb;

			// Ambient
			float3 localNormal;
			localNormal.x = dot( normal.xyz, indata.tang );
			localNormal.y = dot( normal.xyz, indata.bino );
			localNormal.z = dot( normal.xyz, indata.norm );
			float3 ambLight = texCUBE( ambientCubemap, localNormal ).rgb * ambientBrightness;

			// Result
			return float4( diffuse.rgb * ( sunLight + ambLight ), diffuse.a );

		}
	%> }
}

/*
* The glowing edge of fading out objects
*	parameters array is: Alpha test threshold, Edge thickness scale ( higher values mean thinner edges)
*/
renderProgram sfx/fadeedge {

	hwSkinningVersion sfx/fadeedgeSkinningMatrix sfx/fadeedgeHardSkinningMatrix

	state {
		blend blend
		depthFunc less
	}

	program vertex arb { <%
		OPTION ARB_position_invariant;

		MOV	result.color, $colorAttrib;
		DP4 result.texcoord[0].x, $texCoordAttrib, $maskMatrix_s;
		DP4 result.texcoord[0].y, $texCoordAttrib, $maskMatrix_t;		
	%> }
	
	program fragment arb { <%
		OPTION ARB_precision_hint_fastest;
		TEMP R0, R1, mask;
		
		# lookup mask texture
		TEX		mask, fragment.texcoord[0], $mask, 2D;
		SUB		R1, mask.a, $parameters.x;
		#MUL		R1, -1, R1;
		#KIL		R1;
		ABS		R1, R1;
		
		MUL_SAT	R1, $parameters.y, R1;
		SUB		R1, 1, R1;		
		#MUL		mask, R1, mask;

		SUB		R0, R1, 0.05;
		KIL		R0;
		
		#MUL		R1.x, 0.5, R1;
		TEX		result.color, R1.x, $map, 2D;
	
		#MOV		result.color, mask;
		MOV		result.color.a, R1.a;
		#MOV		result.color.gb, 0;
	%> }
}

renderProgram sfx/fadeedgeSkinningMatrix {
	program vertex arb { <%
		TEMP	position;
		useTemplate skinningMatrix_ARB< "position" >

		MOV	result.color, $colorAttrib;
		DP4 result.texcoord[0].x, $texCoordAttrib, $maskMatrix_s;
		DP4 result.texcoord[0].y, $texCoordAttrib, $maskMatrix_t;	
	%> }
	
	program fragment reference sfx/fadeedge
}

renderProgram sfx/fadeedgeHardSkinningMatrix {
	program vertex arb { <%
		TEMP	position;
		useTemplate hardSkinningMatrix_ARB< "position" >

		MOV	result.color, $colorAttrib;
		DP4 result.texcoord[0].x, $texCoordAttrib, $maskMatrix_s;
		DP4 result.texcoord[0].y, $texCoordAttrib, $maskMatrix_t;	
	%> }
	
	program fragment reference sfx/fadeedge
}

/**
	Generic strogg force field shader
	
		Diffuse Matrix: Scales the noise frequency
		parameters: The time (for the noise animation)
		
		Mask Texture: The density of the force field, centered around 128, so 0 is take away force field, 1 is full force field
		Mask Matrix: Affects the density texture coordinates
		parameters2: Noise scale for the density texture, some of the noise will be added to the density texture coordinates

*/
renderProgram sfx/stroggForceField {
	hwSkinningVersion sfx/stroggForceFieldSkinningMatrix sfx/stroggForceFieldHardSkinningMatrix

	program vertex arb { <%
		OPTION ARB_position_invariant;
		TEMP R1;
		
		DP4 result.texcoord[1].x, $texCoordAttrib, $diffuseMatrix_s;
		DP4 result.texcoord[1].y, $texCoordAttrib, $diffuseMatrix_t;
		MOV result.texcoord[1].z, $parameters.x;
		
		DP4 result.texcoord[0].x, $texCoordAttrib, $maskMatrix_s;
		DP4 result.texcoord[0].y, $texCoordAttrib, $maskMatrix_t;
		
		MAD R1, $colorAttrib, $colorModulate, $colorAdd;
		MUL R1, R1, $diffuseColor;
		SUB	R1, 1, R1;
		ADD result.color, R1, R1;
		MOV result.color.w, $colorAttrib;

		MAD	R1, $colorAttrib, $colorModulate, $colorAdd;
		MUL result.color.w, $diffuseColor, R1;
		
		TEMP _F1, _F2;
		SUB		_F2, $positionAttrib, $viewOrigin;
		DP3		_F1.x, _F2, _F2;
		RSQ		_F1.y, _F1.x;
		MUL		_F1.x, _F1.y, _F1.x;
		MUL		_F2.x, $fogDepths.z, 0.5;
		MAD		result.color.secondary, _F1.x, _F2.x, $fogDepths.w; 
		
	%> }

	program fragment cg { <%
		$include "noise.hg"
		
		struct VsOutputs {
			float2 tex		: TEXCOORD0;
			float3 noisePos	: TEXCOORD1;
			float4 color	: COLOR0;
			float4 color1	: COLOR1;
		};
		
		sampler2D rainbowMap : $map;
		sampler2D refreshMap : $mask;
		sampler2D diffuseMap : $diffuseMap;
	
		uniform float2 noiseScale : $parameters2;

		
		float4 fragment( VsOutputs indata ) : COLOR {
		
			// Do a traditional perlin noise lookup
			float noise = perlin( indata.noisePos );		
			
			// Make bands in this noise (marble style)
			float bands = tex2D( rainbowMap, float2( noise, 0 ) ).x;
			
			// The refresh map is where the field is "fresh" or "old" it allows the field to be nonuniform this is a "signed" texture (+1 is fresh -1 is old )
			float refresh = tex2D( refreshMap, indata.tex + noise * noiseScale ).x * 2 - 1;
			bands += refresh;
			
			// The vertex color takes away density so we can fade it
			bands -= indata.color.x;
			
			// Map the grayscale "field density" value to a nice color gradient
			return tex2D( diffuseMap, float2( bands, 0 ) ) * indata.color.a * (1-(indata.color1.r*indata.color1.r));
		}
	%> }
}

renderProgram sfx/stroggForceFieldSkinningMatrix {
	
	program vertex arb { <%
		TEMP	position;
		TEMP	R1;
		
		useTemplate skinningMatrix_ARB< "position" >
		
		DP4 result.texcoord[1].x, $texCoordAttrib, $diffuseMatrix_s;
		DP4 result.texcoord[1].y, $texCoordAttrib, $diffuseMatrix_t;
		MOV result.texcoord[1].z, $parameters.x;
		
		DP4 result.texcoord[0].x, $texCoordAttrib, $maskMatrix_s;
		DP4 result.texcoord[0].y, $texCoordAttrib, $maskMatrix_t;
		
		MAD R1, $colorAttrib, $colorModulate, $colorAdd;
		MUL R1, R1, $diffuseColor;
		SUB	R1, 1, R1;
		ADD result.color, R1, R1;
		MAD	R1, $colorAttrib, $colorModulate, $colorAdd;
		MUL result.color.w, $diffuseColor, R1;
	%> }	
	
	program fragment reference sfx/stroggForceField
}

renderProgram sfx/stroggForceFieldHardSkinningMatrix {
	
	program vertex arb { <%
		TEMP	position;
		TEMP	R1;
		
		useTemplate hardSkinningMatrix_ARB< "position" >
		
		DP4 result.texcoord[1].x, $texCoordAttrib, $diffuseMatrix_s;
		DP4 result.texcoord[1].y, $texCoordAttrib, $diffuseMatrix_t;
		MOV result.texcoord[1].z, $parameters.x;
		
		DP4 result.texcoord[0].x, $texCoordAttrib, $maskMatrix_s;
		DP4 result.texcoord[0].y, $texCoordAttrib, $maskMatrix_t;
		
		MAD R1, $colorAttrib, $colorModulate, $colorAdd;
		MUL R1, R1, $diffuseColor;
		SUB	R1, 1, R1;
		ADD result.color, R1, R1;
		MAD	R1, $colorAttrib, $colorModulate, $colorAdd;
		MUL result.color.w, $diffuseColor, R1;
	%> }	
	
	program fragment reference sfx/stroggForceField
}

renderProgram sfx/stroggForceFieldLarge {

	program vertex cg { <%
	
		struct VsInputs {
			float3 pos : $positionAttrib;
			float4 tex : $texCoordAttrib;
			float4 color : $colorAttrib;
			float3 normal: $normalAttrib;
			$if r_32ByteVtx
			float4 signs : $signAttrib;
			$endif
		};
	
		struct VsOutputs {
			float2 tex		: TEXCOORD0;
			float3 noisePos	: TEXCOORD1;
			float4 color	: TEXCOORD2; // may go over 1
		};
		
		uniform float4 matrixS : $diffuseMatrix_s;
		uniform float4 matrixT : $diffuseMatrix_t;
		
		uniform float4 matrix2S : $maskMatrix_s;
		uniform float4 matrix2T : $maskMatrix_t;		
		uniform float3 time : $parameters;
		uniform float4 colorModulate : $colorModulate;
		uniform float4 colorAdd : $colorAdd;	
		uniform float3 eyePos : $viewOrigin;

		float GetZ( float2 value, float sign ) {
			return ( sqrt( 1.0f - ( dot( value.xy, value.xy ) ) ) * ( sign - 1.f ) );
		}
		
		VsOutputs vertex( VsInputs indata ) {
			VsOutputs outData;

			$if r_32ByteVtx
			indata.tex.xy *= 1.f/4096.f;
			indata.tex.zw = 1.f;
			indata.normal.xy *= 1.f / 32767.f;
			indata.normal.z = GetZ( indata.normal.xy, indata.signs.x );
			$endif

			outData.noisePos.x = dot( indata.tex, matrixS );
			outData.noisePos.y = dot( indata.tex, matrixT );
			outData.noisePos.z = time.x;

			outData.tex.x = dot( indata.tex, matrix2S );
			outData.tex.y = dot( indata.tex, matrix2T );
			
			//float4 color =  indata.color * colorModulate + colorAdd;
			//outData.color = 1.0f - color; //works substractive so flip it here
			//outData.color *= 2;
			
			float3 toEye = indata.pos - eyePos;
			float color = pow( 1.0f - abs( dot ( indata.normal, normalize( toEye ) ) ), 8.0f );
			
			outData.color = color; //works substractive so flip it here
			//outData.color *= 2;			
			
			return outData;
		}		
	%> }

	program fragment cg { <%
		$include "noise.hg"
		
		struct VsOutputs {
			float2 tex		: TEXCOORD0;
			float3 noisePos	: TEXCOORD1;
			float4 color	: TEXCOORD2;
		};
		
		sampler2D rainbowMap : $map;
		sampler2D refreshMap : $mask;
		sampler2D diffuseMap : $diffuseMap;
	
		uniform float2 noiseScale : $parameters2;

		
		float4 fragment( VsOutputs indata ) : COLOR {
		
			// Do a traditional perlin noise lookup
			float noise = perlin( indata.noisePos );		
			
			// Make bands in this noise (marble style)
			float bands = tex2D( rainbowMap, float2( noise, 0 ) ).x;
			
			// The refresh map is where the field is "fresh" or "old" it allows the field to be nonuniform this is a "signed" texture (+1 is fresh -1 is old )
			//float refresh = tex2D( refreshMap, indata.tex + noise * noiseScale ).x * 2 - 1;
			//bands += refresh;
			
			// The vertex color takes away density so we can fade it
			//bands -= indata.color.x;
			
			// Map the grayscale "field density" value to a nice color gradient
			bands *= indata.color.x;
			return tex2D( diffuseMap, float2( bands, 0 ) );
		}
	%> }
}

renderProgram sfx/slipgate {

	program vertex cg { <%
	
		struct VsInputs {
			float3 pos : $positionAttrib;
			float2 tex : $texCoordAttrib;
			float4 color : $colorAttrib;
		};
	
		struct VsOutputs {
			float2 tex		: TEXCOORD0;
		};
		
			
		VsOutputs vertex( VsInputs indata ) {
			VsOutputs outData;
			$if r_32ByteVtx
			indata.tex *= 1.f/4096.f;
			$endif

			outData.tex = indata.tex;
			return outData;
		}		
	%> }

	program fragment cg { <%
		
		struct VsOutputs {
			float2 tex		: TEXCOORD0;
		};
		
		sampler2D starMap : $map;
		sampler2D diffuseMap : $diffuseMap;
		sampler2D rainbowMap : $mask;		
		float4 diffuseColor : $diffuseColor;
		
		float time : $parameters;

		$include "noise.hg"

		float4 fragment( VsOutputs indata ) : COLOR {
		
			
			float2 center = indata.tex - float2( 0.5, 0.5 );
			
			float len = length( center );
			float2 dir = center * ( 1.0f / len );
			
			float angle = atan2( center.y, center.x ) / 3.14159265;
			
			float2 texCoord;
			texCoord.y = ( (1.0f / len ) - time * 0.3 ) * 0.5;
			texCoord.x = (angle + time * 0.002 * ( len * 10 ) );
			
			float4 color = tex2D( starMap, texCoord );
			color.a = (1.0f - (len * 2) * (len * 2) * (len * 2)) * color.r + (1.0f - (len * 2));//color.r + 0.5 * ( 0.5f - len );
			color.rgb += (1.0f - (len * 2)) * 0.5;	//Make centre brighter
			
			return color * diffuseColor;
		}
	%> }
}

// Works as a normal tivial shader except that the vertex color alpha is used to fade to white
// giving the proper meaning of alpha as "disappearing when zero"
renderProgram sfx/blendFilterFade {
	

	program vertex cg { <%
		struct VsInputs {
			float3 pos	: POSITION;
			float4 tex	: $texCoordAttrib;
			float4 col	: $colorAttrib;
		};

		struct VsOutputs {
			float4 col  : COLOR0;
			float2 tex	: TEXCOORD0;
		};

		float4 diffuse_s : $diffuseMatrix_s;
		float4 diffuse_t : $diffuseMatrix_t;
		
		VsOutputs vertex(VsInputs indata) {
			VsOutputs outdata;
			$if r_32ByteVtx
			indata.tex.xy *= 1.f/4096.f;
			indata.tex.zw = 1.f;
			$endif

			outdata.tex.x = dot( indata.tex, diffuse_s);
			outdata.tex.y = dot( indata.tex, diffuse_t );
			outdata.col = indata.col;
	
			return outdata;
		}
	%> }

	program fragment arb { <%
		OPTION ARB_precision_hint_fastest;
		TEMP R0, R1;

		TEX R1, fragment.texcoord, $map, 2D;
		SUB R0, R1, 1;
		MAD	result.color, R0, fragment.color.a, 1;
	%> }
}

// Works as a normal tivial shader except that the vertex color alpha is used to fade to 0.5,0.5,0.5
// giving the proper meaning of alpha as "disappearing when zero"
renderProgram sfx/blendDecalBlendFade {

	hwSkinningVersion 	sfx/blendDecalBlendFade_HardSkin sfx/blendDecalBlendFade_HardSkin

	program vertex cg { <%
		struct VsInputs {
			float3 pos	: POSITION;
			float4 tex	: $texCoordAttrib;
			float4 col	: $colorAttrib;
			float4 tangent: $tangentAttrib;
			$if r_32ByteVtx
			float4 signs : $signAttrib;
			$endif
		};

		struct VsOutputs {
			float4 col  : COLOR0;
			float2 tex	: TEXCOORD0;
		};

		float4 diffuse_s : $diffuseMatrix_s;
		float4 diffuse_t : $diffuseMatrix_t;
		float3 timeParms : $parameters; // Current time, 1 / length of time to fade

		float GetZ( float2 value, float sign ) {
			return ( sqrt( 1.0f - ( dot( value.xy, value.xy ) ) ) * (  sign - 1.f ) );
		}
		
		VsOutputs vertex(VsInputs indata) {
			VsOutputs outdata;
			$if r_32ByteVtx
			indata.tex.xy *= 1.f/4096.f;
			indata.tex.zw = 1.f;
			// I feel dirty
			indata.tangent.w = indata.tangent.x * 32767 + indata.tangent.y;
			$endif

			outdata.tex.x = dot( indata.tex, diffuse_s);
			outdata.tex.y = dot( indata.tex, diffuse_t );
			outdata.col = indata.col;
			
			// Tangent .w has the time of death, timeParms.x has current time, normalize the time delta
			// if the delta is larger than time to fade we use full opacity (i.e. alpha gets clamped to 1)
			outdata.col.a = (indata.tangent.w - timeParms.x) * timeParms.y;
	
			return outdata;
		}
	%> }

	program fragment arb { <%
		OPTION ARB_precision_hint_fastest;
		TEMP R0, R1;

		TEX R1, fragment.texcoord, $map, 2D;
		MOV	result.color.xyz, R1;
		MUL result.color.w, R1, fragment.color.a;
	%> }
}

renderProgram sfx/blendDecalBlendFade_HardSkin {

	program vertex arb userDecompress { <%
		TEMP	pos;
		PARAM	_joints[213] = { program.env[32..244] };	# 74 joints
		PARAM	_mvp[4] = { state.matrix.mvp };

		ADDRESS	_A0;
		TEMP	_R0, _R1, _R2;

		TEMP _tex;
		MOV _tex.zw, $texCoordAttrib;
		$if r_32ByteVtx
		MUL _tex.xy, $texCoordAttrib, 0.000244140625;
		$else
		MUL _tex.xy, $texCoordAttrib, 1;
		$endif

		# accumulate weighted joint matrices
		$if r_32ByteVtx
		ARL		_A0.x, $signAttrib.w;
		$else
		ARL		_A0.x, $tangentAttrib.x;
		$endif
		MOV		_R0, _joints[_A0.x+0];
		MOV		_R1, _joints[_A0.x+1];
		MOV		_R2, _joints[_A0.x+2];
		
		# transform vertex
		DP4		pos.x, _R0, $positionAttrib;
		DP4		pos.y, _R1, $positionAttrib;
		DP4		pos.z, _R2, $positionAttrib;
		MOV		pos.w, 1;

		DP4		result.position.x, _mvp[0], pos;
		DP4		result.position.y, _mvp[1], pos;
		DP4		result.position.z, _mvp[2], pos;
		DP4		result.position.w, _mvp[3], pos;

		DP4	result.texcoord.x, _tex, $diffuseMatrix_s;
		DP4	result.texcoord.y, _tex, $diffuseMatrix_t;

		
		MOV result.color, $colorAttrib;

		TEMP R0;
		$if r_32ByteVtx
			MAD R0.x, $tangentAttrib.x, 32767, $tangentAttrib.y;
		$else
			MOV R0.x, $tangentAttrib.w;
		$endif
		SUB R0.x, R0.x, $parameters;
		MUL result.color.w, R0.x, $parameters.y;
	%> }

	program fragment reference sfx/blendDecalBlendFade
}

renderProgram sfx/maskedInvert {

	program vertex reference trivialWithTextureMatrix

	program fragment arb { <%
		OPTION ARB_precision_hint_fastest;
		TEMP R0;

		TEX R0, fragment.texcoord, $map, 2D;
		MUL R0, R0, fragment.color;
		SUB result.color.a, 1, R0.a;
		MOV result.color.xyz, R0.a;		
	%> }
}

renderProgram sfx/beam {
	program vertex cg { <%
	
		struct VsInputs {
			float3 pos : $positionAttrib;
			float2 tex : $texCoordAttrib;
		};
	
		struct VsOutputs {
			float2 tex	 : TEXCOORD0;
			float1 toEye : TEXCOORD1;
		};
		
		uniform float3 viewOrigin : $viewOrigin;
		
		VsOutputs vertex( VsInputs indata ) {
			VsOutputs outData;

			$if r_32ByteVtx
			indata.tex *= 1.f/4096.f;
			$endif

			float3 toEye = indata.pos - viewOrigin;
			outData.toEye = sqrt( dot( toEye, toEye ) );
			outData.tex = indata.tex;

			return outData;
		}		
	%> }

	program fragment cg { <%
		struct VsOutputs {
			float2 tex	: TEXCOORD0;
			float toEye	: TEXCOORD1;
		};
		
		sampler2D baseMap : $map;
		uniform float4 parameters : $parameters;
		
		float4 fragment( VsOutputs indata ) : COLOR {
			float4 base = tex2D( baseMap, indata.tex );
			
			float distance = saturate( (indata.toEye - parameters.x) / parameters.y );
			base *= distance;
			base.xyz *= parameters.z;
			base.w *= parameters.w;

			return base;
		}
	%> }
}

renderProgram sfx/displace {

	program vertex arb { <%
		TEMP R0;
		TEMP _pos;
		MAD _pos.xyz, $normalAttrib, $parameters.x, $positionAttrib;
		MOV _pos.w, $positionAttrib.w;
		
		PARAM  mvp[4]       = { state.matrix.mvp };
		OUTPUT oPos         = result.position;
		# Transform the vertex to clip coordinates. 
		DP4   oPos.x, mvp[0], _pos;
		DP4   oPos.y, mvp[1], _pos;
		DP4   oPos.z, mvp[2], _pos;
		DP4   oPos.w, mvp[3], _pos;

		DP4	result.texcoord.x, $texCoordAttrib, $diffuseMatrix_s;
		DP4	result.texcoord.y, $texCoordAttrib, $diffuseMatrix_t;
		
		MAD	R0, $colorAttrib, $colorModulate, $colorAdd;
		MUL result.color, $diffuseColor, R0;	
	%> }

	program fragment arb { <%
		OPTION ARB_precision_hint_fastest;
		TEMP R0;

		TEX R0, fragment.texcoord, $map, 2D;
		MUL result.color, R0, fragment.color;
	%> }
}

